"""
Module: process

This module provides functions for processing images
and analyzing marker data.

Functions:
- slice_img_generator(input_file, interpolation=False)
- perform_thresholding(img_gen, is_mri=False, interpolation=False)
- isolate_markers(threshold_gen, save_path, interpolation=False)
- count_difference(ct_path, mri_path, save_path)
- get_coords(markers_path)
"""

import os
import math
import json
import pickle

import numpy as np
import nibabel as nib
import cv2

INTERPOLATION_COEF = 2 ** 3


def slice_img_generator(input_file, interpolation=False):
    """
    Generates slices from a 3D image file.

    This function generates 2D slices from a 3D image file (e.g., .nii file).
    It loads the image file and yields each slice after processing,
    including intensity normalization and resizing.

    Parameters:
    - input_file: A string specifying the path to the input image file.
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Yields:
    2D slices of the image as numpy arrays.
    """
    if interpolation:
        interpol_coeff = INTERPOLATION_COEF
    else:
        interpol_coeff = 1

    try:
        img = nib.load(input_file)
    except nib.filebasedimages.ImageFileError:
        print("Error: Unable to load the .nii file.")
        return
    img_data = img.get_fdata()
    for i in range(img_data.shape[2]):
        slice_data = img_data[:, :, i].copy()
        slice_data = slice_data + np.abs(np.min(slice_data))
        slice_data *= 255.0 / (np.max(slice_data)+1e-5)
        yield cv2.resize(slice_data, None, fx=interpol_coeff, fy=interpol_coeff)


def perform_thresholding(img_gen, is_mri=False, interpolation=False):
    """
    Performs thresholding on images generated by img_gen.

    This function applies thresholding techniques to the images yielded by the img_gen generator.
    It calculates the threshold values based on whether
    the images are MRI or CT, and optionally applies interpolation.
    Thresholded images are yielded as output.

    Parameters:
    - img_gen: A generator yielding images for thresholding.
    - is_mri: A boolean indicating whether the images are MRI (default is False).
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Yields:
    Thresholded images as numpy arrays.
    """
    if interpolation:
        interpol_coeff = INTERPOLATION_COEF
    else:
        interpol_coeff = 1

    # FIXME geometrical model of phantom or autodetect!!!!
    phantom_radius = 144
    for img in img_gen:
        if is_mri:
            img = 255 - img
            min_thresh_val = 215
        else:
            min_thresh_val = 170  # perfect on test data
        mask = np.zeros_like(img)
        img_shape = img.shape
        mask = cv2.circle(mask, (img_shape[0]//2, img_shape[1]//2),
                          phantom_radius * interpol_coeff, (255, 255, 255), -1)
        image = cv2.bitwise_and(img, mask)
        _, thresh1 = cv2.threshold(image, min_thresh_val, 255, cv2.THRESH_BINARY)
        yield thresh1.astype(np.uint8)


def isolate_markers(threshold_gen, save_path, interpolation=False):
    """
    Isolates markers from thresholded images and saves their coordinates.

    This function isolates markers from thresholded images generated by the threshold_gen generator.
    It applies filtering and morphological operations to extract markers from the images.
    The coordinates of the isolated markers are saved into a pickle file.

    Parameters:
    - threshold_gen: A generator yielding thresholded images.
    - save_path: A string specifying the path where the marker coordinates will be saved.
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Returns:
    None
    """

    if interpolation:
        # TODO discover what values are suitable for interpol_mult (find rule)
        min_area = 650
        max_area = 1150
        interpol_coeff = INTERPOLATION_COEF
    else:
        min_area = 5
        max_area = 50
        interpol_coeff = 1

    marker_coords = []
    for threshold_img in threshold_gen:
        image = np.array(threshold_img, dtype=np.uint8)

        # Filter out large non-connecting objects
        contours = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = contours[0] if len(contours) == 2 else contours[1]
        for c in contours:
            area = cv2.contourArea(c)
            if area < min_area:
                cv2.drawContours(image, [c], 0, 0.5, -1)

        # Morph open using elliptical shaped kernel
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (1, 1))
        opening = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel, iterations=3)

        result_image = np.zeros((image.shape[0], image.shape[1], 3), np.uint8)
        slice_coords = []

        contours = cv2.findContours(opening, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = contours[0] if len(contours) == 2 else contours[1]
        for c in contours:
            area = cv2.contourArea(c)
            if min_area < area < max_area:
                ((x, y), _) = cv2.minEnclosingCircle(c)
                cv2.circle(result_image, (int(x), int(y)), 0, (255, 255, 255), 1)
                slice_coords.append(
                    (np.round(int(x) / interpol_coeff, 3), np.round(int(y) / interpol_coeff, 3)))

        # FIXME remove 88 limit
        while len(slice_coords) < 88:
            slice_coords.append((100, 100))
        while len(slice_coords) > 88:
            slice_coords.pop()
        marker_coords.append(slice_coords)

    # FIXME i dont want to save it into pickle dump
    with open(os.path.join(save_path), 'wb') as f:
        pickle.dump(marker_coords, f, pickle.HIGHEST_PROTOCOL)


def count_difference(ct_path, mri_path, save_path):
    """
    Counts differences between CT and MRI markers and saves statistics.

    This function calculates differences between marker coordinates from CT and MRI images.
    It computes various statistics such as mean difference,
    minimum difference, maximum difference, standard deviation,
    and the number of differences exceeding certain thresholds (0.5 mm and 1 mm).
    The results are saved in JSON files for overall statistics and per-slice statistics.

    Parameters:
    - ct_path: A string specifying the path to the pickle file containing CT marker coordinates.
    - mri_path: A string specifying the path to the pickle file containing MRI marker coordinates.
    - save_path: A string specifying the directory where the statistics JSON files will be saved.

    Returns:
    - params: A dictionary containing overall statistics.
    - distances: An array containing all computed differences between CT and MRI marker coordinates.
    - slice_distances: A dictionary containing per-slice statistics.
    """
    # Ensure the output directory exists
    if not os.path.exists(save_path):
        os.makedirs(save_path)

    with open(ct_path, 'rb') as f:
        coords_ct = pickle.load(f)
    with open(mri_path, 'rb') as f:
        coords_mri = pickle.load(f)

    distances = []
    slice_distances = {}

    for slice_num, _ in enumerate(coords_ct):
        slice_distances[f'{slice_num}'] = {}
        slice_distances[f'{slice_num}']['distances'] = []
        for point_ct in coords_ct[slice_num]:
            for point_mri in coords_mri[slice_num]:
                distance = math.sqrt((point_ct[0] - point_mri[0]) ** 2
                                     + (point_ct[1] - point_mri[1]) ** 2)
                if distance < 5 * INTERPOLATION_COEF:
                    slice_distances[f'{slice_num}']['distances'].append(distance)
                    distances.append(distance)

    for key in slice_distances:
        distances_array = np.array(slice_distances[key]['distances'])
        if len(distances_array) > 0:
            slice_distances[key]['Mean difference, mm'] = float(np.mean(distances_array))
            non_zero = distances_array[np.nonzero(distances_array)]
            if len(non_zero) > 0:
                slice_distances[key]['Min difference, mm'] =\
                    float(np.min(distances_array[np.nonzero(distances_array)]))
            else:
                slice_distances[key]['Min difference, mm'] = float(0)
            slice_distances[key]['Max difference, mm'] = float(np.max(distances_array))
            slice_distances[key]['Std, mm'] = float(np.std(distances_array))
            slice_distances[key]['Number of differences > 0.5 mm'] =\
                int((distances_array > 0.5).sum())
            slice_distances[key]['Number of differences > 1 mm'] = int((distances_array > 1).sum())
        else:
            slice_distances[key]['Mean difference, mm'] = float(0)
            slice_distances[key]['Min difference, mm'] = float(0)
            slice_distances[key]['Max difference, mm'] = float(0)
            slice_distances[key]['Std, mm'] = float(0)
            slice_distances[key]['Number of differences > 0.5 mm'] = int(0)
            slice_distances[key]['Number of differences > 1 mm'] = int(0)

    distances = np.array(distances)
    mean_distance = np.mean(distances)
    non_zero = distances[np.nonzero(distances)]
    if len(non_zero) > 0:
        min_distance = np.min(distances[np.nonzero(distances)])
    else:
        min_distance = float(0)
    max_distance = np.max(distances)
    std_distance = np.std(distances)
    num_05 = (distances > 0.5).sum()
    num_1 = (distances > 1).sum()

    params = {'Mean difference, mm': np.round(float(mean_distance), 2),
              'Min difference, mm': np.round(float(min_distance), 2),
              'Max difference, mm': np.round(float(max_distance), 2),
              'Std, mm': np.round(float(std_distance), 2),
              'Number of differences > 0.5 mm': int(num_05),
              'Number of differences > 1 mm': int(num_1)}

    with open(os.path.join(save_path, 'difference_stats.json'), 'w') as fp:
        json.dump(params, fp)
    with open(os.path.join(save_path, 'slice_difference_stats.json'), 'w') as fp:
        json.dump(slice_distances, fp)
    return params, distances, slice_distances


def get_coords(markers_path):
    """
    Retrieve coordinates of markers from a specified pickle file.

    This function reads the pickle file located at the given path
    and extracts the coordinates of markers.
    The pickle file should contain a 3D numpy array
    representing marker coordinates.
    Each marker is represented by its x, y, and z coordinates.

    Parameters:
    - markers_path: A string specifying the path to the pickle file
    containing marker coordinates.

    Returns:
    A list of lists, where each inner list represents the coordinates
    of a marker in the format [x, y, z].
    """
    with open(markers_path, 'rb') as f:
        coords_array = np.array(pickle.load(f))

    shape_coords = coords_array.shape
    list_of_points = []
    for z_slice in range(shape_coords[0]):
        for num_of_point in range(shape_coords[1]):
            list_of_points.append([coords_array[z_slice, num_of_point, 0],
                                   coords_array[z_slice, num_of_point, 1],
                                   z_slice])
    return list_of_points
