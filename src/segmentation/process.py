"""
Module: process

This module provides functions for processing images
and analyzing marker data.
"""

import os
import math
import json
import pickle
import numpy as np
import nibabel as nib
import cv2

INTERPOLATION_COEF = 2**3


def slice_img_generator(input_file, interpolation=False):
    """
    Generates slices from a 3D image file.

    This function generates 2D slices from a 3D image file (e.g., .nii file).
    It loads the image file and yields each slice after processing,
    including intensity normalization and resizing.

    Parameters:
    - input_file: A string specifying the path to the input image file.
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Yields:
    2D slices of the image as numpy arrays.
    """
    if interpolation:
        interpol_coeff = INTERPOLATION_COEF
    else:
        interpol_coeff = 1

    try:
        img = nib.load(input_file)
    except nib.filebasedimages.ImageFileError:
        print("Error: Unable to load the .nii file.")
        return
    img_data = img.get_fdata()
    for i in range(img_data.shape[2]):
        slice_data = img_data[:, :, i].copy()
        slice_data = slice_data + np.abs(np.min(slice_data))
        slice_data *= 255.0 / (np.max(slice_data) + 1e-5)
        yield cv2.resize(slice_data, None, fx=interpol_coeff, fy=interpol_coeff)


def perform_thresholding(img_gen, is_mri=False, interpolation=False):
    """
    Performs thresholding on images generated by img_gen.

    This function applies thresholding techniques to the images yielded by the img_gen generator.
    It calculates the threshold values based on whether
    the images are MRI or CT, and optionally applies interpolation.
    Thresholded images are yielded as output.

    Parameters:
    - img_gen: A generator yielding images for thresholding.
    - is_mri: A boolean indicating whether the images are MRI (default is False).
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Yields:
    Thresholded images as numpy arrays.
    """
    if interpolation:
        interpol_coeff = INTERPOLATION_COEF
        outer_thickness = 25
        block_size = 31
    else:
        interpol_coeff = 1
        outer_thickness = 3
        block_size = 3

    # FIXME geometrical model of phantom or autodetect!!!!
    phantom_radius = 144
    for img in img_gen:
        if is_mri:
            img = img.astype("uint8")
            img = 255 - img
            threshold_val = -2  # make it a setting
        else:
            img = img.astype("uint8")
            threshold_val = -2  # make it a setting

        mask = cv2.circle(
            np.zeros(shape=img.shape, dtype="uint8"),
            (img.shape[0] // 2, img.shape[1] // 2),
            phantom_radius * interpol_coeff,
            (255, 255, 255),
            -1,
        )
        image = cv2.bitwise_and(img, mask)
        thresh1 = cv2.adaptiveThreshold(
            image,
            255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY,
            block_size,
            threshold_val,
        )

        cnts, _ = cv2.findContours(thresh1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        cnt = max(cnts, key=cv2.contourArea)

        out = np.zeros(thresh1.shape, np.uint8)
        cv2.drawContours(out, [cnt], -1, 255, outer_thickness)
        thresh1 = thresh1 - out

        yield thresh1.astype(np.uint16)  # why np.uint16?


def isolate_markers(threshold_gen, save_path, interpolation=False):
    """
    Isolates markers from thresholded images and saves their coordinates.

    This function isolates markers from thresholded images generated by the threshold_gen generator.
    It applies filtering and morphological operations to extract markers from the images.
    The coordinates of the isolated markers are saved into a pickle file.

    Parameters:
    - threshold_gen: A generator yielding thresholded images.
    - save_path: A string specifying the path where the marker coordinates will be saved.
    - interpolation: A boolean indicating whether interpolation is applied (default is False).

    Returns:
    None
    """

    if interpolation:
        min_area = 50
        max_area = 1150
        interpol_coeff = INTERPOLATION_COEF
    else:
        min_area = 2
        max_area = 80
        interpol_coeff = 1

    marker_coords = []
    for threshold_img in threshold_gen:
        image = np.array(threshold_img / 255, dtype=np.uint8)

        # Filter out large non-connecting objects
        contours = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = contours[0] if len(contours) == 2 else contours[1]
        for c in contours:
            area = cv2.contourArea(c)
            if area < min_area:
                cv2.drawContours(image, [c], 0, 0.5, -1)

        # Morph open using elliptical shaped kernel
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (1, 1))
        opening = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel, iterations=3)

        result_image = np.zeros((image.shape[0], image.shape[1], 3), np.uint8)
        slice_coords = []

        contours = cv2.findContours(opening, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours = contours[0] if len(contours) == 2 else contours[1]

        for c in contours:
            area = cv2.contourArea(c)
            if min_area < area < max_area:
                ((x, y), _) = cv2.minEnclosingCircle(c)
                cv2.circle(result_image, (int(x), int(y)), 0, (255, 255, 255), 1)
                slice_coords.append(
                    (
                        np.round(int(x) / interpol_coeff, 3),
                        np.round(int(y) / interpol_coeff, 3),
                    )
                )

        # FIXME remove 88 limit
        while len(slice_coords) < 88:
            slice_coords.append((100, 100))
        while len(slice_coords) > 88:
            slice_coords.pop()
        marker_coords.append(slice_coords)

    # FIXME i dont want to save it into pickle dump
    with open(os.path.join(save_path), "wb") as f:
        pickle.dump(marker_coords, f, pickle.HIGHEST_PROTOCOL)


def count_difference(ct_path, mri_path, save_path):
    """
    Counts differences between CT and MRI markers and saves statistics.

    This function calculates differences between marker coordinates from CT and MRI images.
    It computes various statistics such as mean difference,
    minimum difference, maximum difference, standard deviation,
    and the percentage of differences exceeding certain thresholds (0.5 mm and 1 mm).
    The results are saved in JSON files for overall statistics and per-slice statistics.

    Parameters:
    - ct_path: A string specifying the path to the pickle file containing CT marker coordinates.
    - mri_path: A string specifying the path to the pickle file containing MRI marker coordinates.
    - save_path: A string specifying the directory where the statistics JSON files will be saved.

    Returns:
    - params: A dictionary containing overall statistics.
    - distances: An array containing all computed differences between CT and MRI marker coordinates.
    - slice_distances: A dictionary containing per-slice statistics.
    """
    # Ensure the output directory exists
    if not os.path.exists(save_path):
        os.makedirs(save_path)

    with open(ct_path, "rb") as f:
        coords_ct = pickle.load(f)
    with open(mri_path, "rb") as f:
        coords_mri = pickle.load(f)

    distances = []
    slice_distances = {}

    for slice_num, _ in enumerate(coords_ct):
        slice_distances[f"{slice_num}"] = {}
        slice_distances[f"{slice_num}"]["distances"] = []
        for point_ct in coords_ct[slice_num]:
            if point_ct[0] == 100 and point_ct[1] == 100:
                continue  # Skip points where x=100 and y=100
            for point_mri in coords_mri[slice_num]:
                if point_mri[0] == 100 and point_mri[1] == 100:
                    continue  # Skip points where x=100 and y=100
                distance = math.sqrt(
                    (point_ct[0] - point_mri[0]) ** 2
                    + (point_ct[1] - point_mri[1]) ** 2
                )
                if distance < 5 * INTERPOLATION_COEF:
                    slice_distances[f"{slice_num}"]["distances"].append(distance)
                    distances.append(distance)

    # Filter distances to keep only values <= 5 mm
    distances = np.array(distances)
    filtered_distances = distances[distances <= 5]

    for key in slice_distances:
        distances_array = np.array(slice_distances[key]["distances"])
        distances_array = distances_array[distances_array <= 5]  # Filter per-slice distances

        if len(distances_array) > 0:
            slice_distances[key]["Mean difference, mm"] = float(np.mean(distances_array))
            non_zero = distances_array[np.nonzero(distances_array)]
            if len(non_zero) > 0:
                slice_distances[key]["Min difference, mm"] = float(np.min(non_zero))
            else:
                slice_distances[key]["Min difference, mm"] = float(0)
            slice_distances[key]["Max difference, mm"] = float(np.max(distances_array))
            slice_distances[key]["Std, mm"] = float(np.std(distances_array))
            slice_distances[key]["Percentage of differences > 0.5 mm"] = float((distances_array > 0.5).sum() / len(distances_array) * 100)
            slice_distances[key]["Percentage of differences > 1 mm"] = float((distances_array > 1).sum() / len(distances_array) * 100)
        else:
            slice_distances[key]["Mean difference, mm"] = float(0)
            slice_distances[key]["Min difference, mm"] = float(0)
            slice_distances[key]["Max difference, mm"] = float(0)
            slice_distances[key]["Std, mm"] = float(0)
            slice_distances[key]["Percentage of differences > 0.5 mm"] = float(0)
            slice_distances[key]["Percentage of differences > 1 mm"] = float(0)

    if len(filtered_distances) > 0:
        mean_distance = np.mean(filtered_distances)
        non_zero = filtered_distances[np.nonzero(filtered_distances)]
        if len(non_zero) > 0:
            min_distance = np.min(non_zero)
        else:
            min_distance = float(0)
        max_distance = np.max(filtered_distances)
        std_distance = np.std(filtered_distances)
        num_05 = (filtered_distances > 0.5).sum()
        num_1 = (filtered_distances > 1).sum()
        percentage_05 = (num_05 / len(filtered_distances)) * 100
        percentage_1 = (num_1 / len(filtered_distances)) * 100
    else:
        mean_distance = float(0)
        min_distance = float(0)
        max_distance = float(0)
        std_distance = float(0)
        percentage_05 = float(0)
        percentage_1 = float(0)

    params = {
        "Mean difference, mm": np.round(float(mean_distance), 2),
        "Min difference, mm": np.round(float(min_distance), 2),
        "Max difference, mm": np.round(float(max_distance), 2),
        "Std, mm": np.round(float(std_distance), 2),
        "Percentage of differences > 0.5 mm": np.round(float(percentage_05), 2),
        "Percentage of differences > 1 mm": np.round(float(percentage_1), 2),
    }

    with open(os.path.join(save_path, "difference_stats.json"), "w") as fp:
        json.dump(params, fp)
    with open(os.path.join(save_path, "slice_difference_stats.json"), "w") as fp:
        json.dump(slice_distances, fp)
    return params, distances, slice_distances


def get_coords(markers_path):
    """
    Retrieve coordinates of markers from a specified pickle file.

    This function reads the pickle file located at the given path
    and extracts the coordinates of markers.
    The pickle file should contain a 3D numpy array
    representing marker coordinates.
    Each marker is represented by its x, y, and z coordinates.

    Parameters:
    - markers_path: A string specifying the path to the pickle file
    containing marker coordinates.

    Returns:
    A list of lists, where each inner list represents the coordinates
    of a marker in the format [x, y, z].
    """
    with open(markers_path, "rb") as f:
        coords_array = np.array(pickle.load(f))

    shape_coords = coords_array.shape
    list_of_points = []
    for z_slice in range(shape_coords[0]):
        if 35 <= z_slice <= 105:  # Only include layers z from 35 to 105
            for num_of_point in range(shape_coords[1]):
                x = coords_array[z_slice, num_of_point, 0]
                y = coords_array[z_slice, num_of_point, 1]
                if x == 100 and y == 100:  # Skip points where x=100 and y=100
                    continue
                list_of_points.append([x, y, z_slice])

    return list_of_points
